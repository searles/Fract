// Define name of extern parameters
val maxIterationLabel = "Maximum Iteration Count";
val functionLabel = "Function (z[n])";
val maxExponentLabel = "Maximum Exponent";
val isJuliaSetLabel = "Julia Set";
val juliaSetParameterLabel = "Julia Set Parameter";
val z0Label = "Start Value (z[0])";
val useBailoutLabel = "Use Bailout (unset for eg Newton Fractals)";
val bailoutRadiusLabel = "Bailout Radius";
val bailoutValueLabel = "Bailout Value";
val bailoutColorValueLabel = "Bailout Color Value";
val bailoutHeightLabel = "Bailout Height";
val bailoutPaletteLabel = "Bailout Palette";
val epsilonRadiusLabel = "Epsilon Radius";
val lakeValueLabel = "Lake Value";
val lakeColorValueLabel = "Lake Color Value";
val lakeHeightLabel = "Lake Height";
val lakePaletteLabel = "Lake Palette";

val addendFunctionLabel = "Addend Function";
val sumStartValueLabel = "Start Value of Sum";
val startIndexLabel = "Start Index of Sum";

// Define default scale and palette
declareScale(2, 0, 0, 2, 0, 0);
declarePalette(lakePaletteLabel, 1, 1, [0, 0, #ff000000]);

extern maxIteration: maxIterationLabel = "250";

class Calculator {

  extern sumStartValue: sumStartValueLabel = "0";
  var sum: Cplx = sumStartValue;

  // iteration counter
  var n: Int = 0;

  extern isJuliaSet: isJuliaSetLabel = "false";

  // parameter
  var c: Cplx = if(isJuliaSet) {
    extern juliaSetParameter: juliaSetParameterLabel = "-0.75: 0.25";
    juliaSetParameter
  } else {
    point;
  }

  // z[n]
  var z: Cplx = if(isJuliaSet)
    point
  else {
    extern z0: z0Label = "0";
    z0;
  }

  // z[n-1]
  var lastZ: Cplx = 0:0;

  /*
   * Performs one full calculation step
   * z, lastZ and n are modified.
   * true is returned if none of the break conditions succeeds.
   */
  fun step() {
    extern function: functionLabel = "z^2 + c";
    var nextZ = function;

    var radZ = rad nextZ;
    var dz = nextZ - z;
    var radDz = rad dz;

    extern useBailout: useBailoutLabel = "true";

    if(useBailout) {
        declarePalette(bailoutPaletteLabel, 6, 2,
          [0, 0, #ff000000], [1, 0, #ff4400aa], [5, 0, #ff4400aa], [2, 0, #ffffdd22], [4, 0, #ffffdd22], [3, 0, #ffffffff],
          [0, 1, #ff000000], [1, 1, #ffffffff], [5, 1, #ffffffff], [2, 1, #ff000000], [4, 1, #ff000000], [3, 1, #ffffffff]
        );

        extern bailoutRadius: bailoutRadiusLabel = "1e9";

        extern addendFunction: addendFunctionLabel = "norm nextZ ^ 2";
        extern startIndex: startIndexLabel = "0";
    }

    if(if(useBailout) radZ >= bailoutRadius else false) {
      extern maxExponent: maxExponentLabel = "2";

      // bailout
      var continuousAddend =
        1 - log(log radZ / log bailoutRadius) / log maxExponent;

      var branchingAverage = (sum + continuousAddend * addendFunction) / (n + continuousAddend - startIndex);

      extern bailoutValue: bailoutValueLabel = "branchingAverage";
      extern bailoutColorValue: bailoutColorValueLabel = "value";
      extern bailoutHeight: bailoutHeightLabel = "re value";

      var value = bailoutValue;
      setResult(1, bailoutColorValue, bailoutHeight);

      false
    } else {
      extern epsilonRadius: epsilonRadiusLabel = "1e-9";

      extern lakeValue: lakeValueLabel = "radDz : radZ";
      extern lakeColorValue: lakeColorValueLabel = "value";
      extern lakeHeight: lakeHeightLabel = "re value";

      if(radDz < epsilonRadius) {
        var value = lakeValue;
        setResult(0, lakeColorValue, lakeHeight);

        false
      } else if(not next(maxIteration, n)) {
        // lake
        var value = lakeValue;
        setResult(0, lakeColorValue, lakeHeight);

        false
      } else {
        // next step.
        if(n > startIndex) {
          sum = sum + addendFunction;
        }

        lastZ = z;
        z = nextZ;

        true
      }
    }
  }
}

// Main starts here. It is rather simple and linear.

val calculator = Calculator()

while (
  calculator.step()
);