val z0 = 0:0;
var c = point;
var n = 0;

var z = z0;

val bailoutValue = 64;
val maxExponent = 2;
val maxIterationCount = 1024;

while ({
    z = z^maxExponent + c;

    var radZ = rad z;

    if(radZ > bailoutValue) {
        var continuousAddend = -log(radZ / log bailoutValue) / log maxExponent;
        var continuousN = n + continuousAddend;
        setResult(1, log (1 + continuousN), continuousN);
        false
    } else if(not next(maxIterationCount, n)) {
        setResult(0, arc z / 2 pi, log radZ);
        false
    } else {
        true
    }
})