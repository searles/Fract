val z0 = 0:0;
var c = point;
var n = 0;

var z = z0;

val bailoutValue = 64;
val maxExponent = 2;
val maxIterationCount = 1024;

while ({
	z = z^maxExponent + c;

	var radZ = rad z;

	if(radZ > bailoutValue) {
		var continuousAddend = log(log radZ / log bailoutValue) / log maxExponent;
		var logN = log(n + 1 - continuousAddend);
		setResult(0, logN, logN);
		false
	} else if(not next(maxIterationCount, n)) {
		setResult(1, 0, log radZ);
		false
	} else {
		true
	}
})